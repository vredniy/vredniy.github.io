<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Записки Вредного программиста]]></title>
  <link href="http://vredniy.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://vredniy.github.io/"/>
  <updated>2014-02-01T17:02:39+04:00</updated>
  <id>http://vredniy.github.io/</id>
  <author>
    <name><![CDATA[Зудочкин Дима]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Парсим news.ycombinator.com или не рельсами едиными жив человек (Sinatra, DataMapper)]]></title>
    <link href="http://vredniy.github.io/2013/03/sinatra-datamapper-news-combinator"/>
    <updated>2013-03-05T23:29:26+04:00</updated>
    <id>http://vredniy.github.io/2013/03/sinatra-datamapper-news-combinator</id>
    <content type="html"><![CDATA[<p>Дело было вечером, делать было нечего и решил я написать небольшое приложение на Sinatra с Datamapper'ом. За идеей далеко ходить также не пришлось: решил написать небольшой &ldquo;фильтратор&rdquo; интересного для меня контента из новостей news.ycombinator.ru.<!-- more --> Не стал изобретать велосипед на этот раз и интересными буду считать новости, названия которых содержат определенные слова. Будем отображать список прочитанных и непрочитанных новостей. Список новостей каждый час будет обновляться по cron'у &ndash; вот и вся задача.</p>

<p>Начнем с реализации: для этого нам понадобится:</p>

<ul>
<li>data_mapper с двумя адаптерами (sqlite3 для локального использование и postgresql для production'а)</li>
<li>sinatra</li>
<li>coffeeScript, хоть можно было и легко обойтись без него</li>
<li>slim в качестве шаблонизатора</li>
</ul>


<p>Итак, поехали:</p>

<p>Gemfile:</p>

<p><div>
  <pre><code class='ruby'>source &amp;lsquo;&lt;a href=&quot;https://rubygems.org&quot;&gt;https://rubygems.org&lt;/a&gt;&amp;rsquo;&lt;/p&gt;

&lt;p&gt;gem &amp;lsquo;sinatra&amp;rsquo;
gem &amp;lsquo;data_mapper&amp;rsquo;&lt;/p&gt;

&lt;p&gt;group :development do
  gem &amp;lsquo;dm-sqlite-adapter&amp;rsquo;
  gem &amp;lsquo;capistrano&amp;rsquo;
end&lt;/p&gt;

&lt;p&gt;group :production do
  gem &amp;lsquo;dm-postgres-adapter&amp;rsquo;
end&lt;/p&gt;

&lt;p&gt;gem &amp;lsquo;slim&amp;rsquo;
gem &amp;lsquo;coffee-script&amp;rsquo;
gem &amp;lsquo;whenever&amp;rsquo;, :require =&gt; false&lt;/p&gt;

&lt;p&gt;gem &amp;lsquo;nokogiri&amp;rsquo;&lt;/p&gt;

&lt;p&gt;gem &amp;lsquo;unicorn&amp;rsquo;</code></pre>
</div>
</p>

<p>В нем нет ничего необычного, добавляем необходимые гемы для разных сред.</p>

<p>Теперь самое интересное: основной файл приложения, который занимает больше всего места.</p>

<p>./app.rb</p>

<p>``` ruby</p>

<p>require &lsquo;sinatra&rsquo;
require &lsquo;slim&rsquo;</p>

<p>require &lsquo;coffee-script&rsquo;
require &lsquo;data_mapper&rsquo;</p>

<p>DataMapper::Property::String.length(400)</p>

<p>configure :development do
  DataMapper.setup(:default, &lsquo;sqlite3:./db/articles.db&rsquo;)
end</p>

<p>configure :production do
  DataMapper.setup(:default, &lsquo;postgres://deployer:funnydb@localhost/ycombinator&rsquo;)
end</p>

<p>class Article
  include DataMapper::Resource</p>

<p>  INTERESTING_KEYWORDS = %w(ruby rails coffee js javascript ember angular</p>

<pre><code>backbone tdd rspec shoulda gem unicorn nginx sinatra vim mac)
</code></pre>

<p>  property :id, Serial
  property :url, String, :unique_index => :u, :required => true, :format => :url
  property :title, String, :required => true, :index => true
  property :interesting, Boolean, :default => false
  property :read_at, DateTime
  timestamps :created_at, :updated_on</p>

<p>  def interesting?</p>

<pre><code>!!(title =~ Regexp.new(INTERESTING_KEYWORDS.join('|'), Regexp::IGNORECASE))
</code></pre>

<p>  end</p>

<p>  def self.interesting_to_me</p>

<pre><code>all(:interesting =&gt; true)
</code></pre>

<p>  end</p>

<p>  def self.unread</p>

<pre><code>all(:read_at =&gt; nil)
</code></pre>

<p>  end</p>

<p>  def self.read</p>

<pre><code>all(:read_at.not =&gt; nil)
</code></pre>

<p>  end</p>

<p>  def self.search(term=&lsquo;&rsquo;)</p>

<pre><code>if DataMapper.repository.adapter.options[:scheme] == 'sqlite3'
  all(:title.like =&gt; "%#{term.to_s}%")
else
  all(:conditions =&gt; [ 'title ILIKE ?', "%#{term.to_s}%" ])
end
</code></pre>

<p>  end
end</p>

<p>DataMapper.finalize</p>

<h1>DataMapper.auto_migrate!</h1>

<p>DataMapper.auto_upgrade!</p>

<p>helpers do
  def do_process(scope=nil)</p>

<pre><code>@search_term = params[:term].nil? ? nil : params[:term]
@articles = case scope
            when :all
              Article
            when :all_read
              Article.read
            when :all_unread
              Article.unread
            else
              Article.interesting_to_me.unread
            end.search(@search_term)
slim :index
</code></pre>

<p>  end
end</p>

<p>get &lsquo;/application.js&rsquo; do
  coffee :application
end</p>

<p>post &lsquo;/:id/read&rsquo; do
  @article = Article.get(params[:id])
  @article.read_at = Time.now
  @article.save
end</p>

<p>get &lsquo;/all&rsquo; do
  do_process :all
end</p>

<p>get &lsquo;/all/read&rsquo; do
  do_process :all_read
end</p>

<p>get &lsquo;/all/unread&rsquo; do
  do_process :all_unread
end</p>

<p>get &lsquo;/*&rsquo; do
  do_process
end</p>

<p>```</p>

<p>А теперь немного комментариев:</p>

<ul>
<li><p><strong>1-5 строки</strong> &ndash; подключаем необходимые для работы файлы</p></li>
<li><p><strong>7 строка</strong> &ndash; сообщаем DataMapper'y, что длина строки (String) не 80 символов, а 400, 255 не хватает.</p></li>
<li><p><strong>9-15</strong> &ndash; конфигурируем два адаптера: один для разработки, другой для продакшна.</p></li>
<li><p><strong>17-53</strong></p>

<ul>
<li><p><strong>20,21</strong> &ndash; объявляем интересные мне ключевые слова</p></li>
<li><p><strong>23-28</strong> &ndash; описываем все поля, которые будут в нашей модели</p></li>
<li><p><strong>30-32</strong> &ndash; метод interesting? определяет по заголовку новости интересна она мне или нет</p></li>
<li><p><strong>34-40</strong> &ndash; несколько используемых в приложении scope'ов</p></li>
<li><p><strong>46-52</strong> &ndash; метод search (из-за того, что в Postgresql like учитывает регистр букв, пришлось переписать оператор поиска на ilike, который этого не делает)</p></li>
</ul>
</li>
<li><p><strong>60-73</strong> &ndash; объявляем метод, который является &ldquo;сердцем&rdquo; и в зависимости от параметра заполняет коллекцию определенными статьями и рендерит вьюху ./views/index.slim</p></li>
<li><p><strong>76-78</strong> &ndash; рендерим coffeeScript, которые делает следующее, если мы кликам по новости, то отправляем ajax post запрос и помечаем новость как прочитанную (read_at = Time.now)</p></li>
<li><p><strong>80-84</strong> &ndash; сам метод, который помечает новость прочитанной при post запросе</p></li>
<li><p><strong>86-100</strong> &ndash; разные коллекции (все, прочитанные, непрочитанные и т.д.)</p></li>
</ul>


<p>теперь Rakefile, который будет парсить news.ycombinator.com каждый час</p>

<p>``` ruby</p>

<p>require &lsquo;./app&rsquo;</p>

<p>require &lsquo;nokogiri&rsquo;
require &lsquo;open-uri&rsquo;</p>

<p>desc &lsquo;Parse all articles&rsquo;
task :parse do
  doc = Nokogiri::HTML(open(&lsquo;<a href="http://news.ycombinator.com/">http://news.ycombinator.com/</a>&rsquo;))
  links = doc.css(&lsquo;td.title a&rsquo;)
  next_page_link = links.pop</p>

<p>  links.each do |link|</p>

<pre><code>href = link[:href]
text = link.children.text

unless Article.first(:url =&gt; href)
  Article.create(:url =&gt; href, :title =&gt; text)
end
</code></pre>

<p>  end</p>

<p>  puts Time.now.to_s
end</p>

<p>desc &lsquo;Update Interesting tasks&rsquo;
task :update_interesting do
  Article.all.each do |a|</p>

<pre><code>a.update(:interesting =&gt; a.interesting?)
puts "#{a.id} updated"
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>В нем всего две задачи: первая &ndash; парсит новости, вторая нужна для того, что если вдруг изменися интересные ключевые слова, то вы сможете легко обновить список инетересных вам новостей.</p>

<p>Файл, который отвечает за частоту выполнения определенных тасков ./config/shedule.rb
``` ruby</p>

<p>set :output, &lsquo;/home/deployer/projects/ycombinator/shared/log/shedule.log&rsquo;</p>

<p>job_type :rake, &ldquo;cd :path &amp;&amp; RACK_ENV=:environment bundle exec rake :task &mdash;silent :output&rdquo;</p>

<p>every :hour do
  rake &lsquo;parse&rsquo;
end</p>

<p>```</p>

<p>В первой строчке я указываю путь до файла с логами, чтобы каждый раз при запуске rake task'а в конец добавлялось время последнего обновления. В блоке с every можно очень гибко указать как часто выполняться, смотрите документацию к гему whenever.</p>

<p>Также я добавил несколько строк к файлу, выполняющего деплой из <a href="/unicorn-rbenv-nginx-postgresql/">Разворачиваем Rails приложение вместе с Capistrano</a>. ./config/deploy.rb</p>

<p>``` ruby</p>

<p>&hellip;
set :application, &lsquo;ycombinator&rsquo;
set :whenever_command, &ldquo;bundle exec whenever&rdquo;
require &ldquo;whenever/capistrano&rdquo;
&hellip;</p>

<p>```</p>

<p>Теперь мы можем запустить обновления cron'а deployer'а командой <code>cap whenever:update_crontab</code></p>

<p>После ее запуска вы можете проверить, что вышло, обновился ли cron, запустив на сервере, список cron задач: <code>crontab -l</code></p>

<p>Без комментариев оставлю вьюхи, но текст их приведу.</p>

<p>./views/application.coffee
``` coffeescript</p>

<p>$ &ndash;>
  $(&ldquo;.article&rdquo;).click &ndash;></p>

<pre><code>$.post "/" + $(this).attr("id") + "/read", -&gt;
$(this).parent('li').remove()
</code></pre>

<p>```</p>

<p>./views/layout.slim
``` ruby</p>

<p>doctype html</p>

<p>head
  title Ycombinator
  script src=&ldquo;<a href="http://vredniy.github.io//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js">http://vredniy.github.io//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js</a>&rdquo;
  script src=&ldquo;<a href="http://vredniy.github.io/application.js">http://vredniy.github.io/application.js</a>&rdquo;</p>

<p>body
  a{ href=&ldquo;<a href="http://vredniy.github.io/all">http://vredniy.github.io/all</a>&rdquo; } All
  br
  a{ href=&ldquo;<a href="http://vredniy.github.io/all/read">http://vredniy.github.io/all/read</a>&rdquo; } All read
  br
  a{ href=&ldquo;<a href="http://vredniy.github.io/all/unread">http://vredniy.github.io/all/unread</a>&rdquo; } All unread
  br
  a{ href=&ldquo;<a href="http://vredniy.github.io/">http://vredniy.github.io/</a>&rdquo; } Home
  hr
  == yield</p>

<p>```</p>

<p>И наконец, ./views/index.slim
``` ruby</p>

<p>h1
  &lsquo; Unread articles
  &ndash; if @search_term</p>

<pre><code>= "searched by: '#{ @search_term }'"
</code></pre>

<p>p Search form
form{ method=&ldquo;get&rdquo; action=&ldquo;&rdquo; }
  input{ type=&ldquo;text&rdquo; name=&ldquo;term&rdquo; value=&ldquo;#{ @search_term }&rdquo; }
  input{ type=&ldquo;submit&rdquo; value=&ldquo;Find&rdquo; }</p>

<ul>
<li>if @search_term
a{ href=&ldquo;<a href="http://vredniy.github.io/">http://vredniy.github.io/</a>&rdquo; } Home</li>
</ul>


<p>ul
  &ndash; @articles.each do |article|</p>

<pre><code>li
  a{ href="#{ article.url }" id="#{ article.id }" class="article" target="_blank" }
    = article.title
</code></pre>

<p>```</p>

<p>Получислось такое незамысловатое и некрасивое приложение :).</p>

<p><img class="image" src="/images/posts/2013-03-sinatra-datamapper-news-combinator/Screen-Shot-2013-03-05-at-10.33.43-PM.png"></p>

<p>Вместо заключения: чтобы мозги не были напичканы только рельсами (читать как одним фреймворком), мне кажется, необходимо покидать зону комфорта и писать небольшые приложения для души на смежных технологиях. Скажу честно, для того, чтобы реализовать это несложное приложение у меня ушло масса времени на чтение мануалов к Sinatra, DataMapper'у, нежели на написание кода. Но мне понравилось, практической ценности, конечно, приложение почти не имеет, но мозги размялись однозначно. Разминай мозги, коллега :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Разворачиваем rails приложение вместе с capistrano]]></title>
    <link href="http://vredniy.github.io/2013/03/unicorn-rbenv-nginx-postgresql"/>
    <updated>2013-03-03T16:13:05+04:00</updated>
    <id>http://vredniy.github.io/2013/03/unicorn-rbenv-nginx-postgresql</id>
    <content type="html"><![CDATA[<p>Здравствуйте, дорогие друзья, сегодня я расскажу вам как быстро развернуть Ruby on Rails приложение на сервере. Если у вас маленькое приложение, которое посещает 10 человек в день, то вам достаточно будет задеплоить его на heroku (имею в виду бесплатный тариф) и не читать все то, что написано ниже. Если же у вас приложение побольше, то милости прошу на огонек.<!-- more --></p>

<h3>Сервер</h3>

<p>Сервер: я буду настраивать все на Ubuntu 12.04 (64x), но не думаю, что должны возникнуть сложности с подобной операционной системой. Если же появятся траблы, пишите в комментах, попытаемся решить вместе.</p>

<p>Итак, поехали, логинимся по root'ом и производим базовую настройку сервера. Я начинаю всегда с локалей, для этого делаю следующее.</p>

<p><strong>localedef ru_RU.UTF-8 -i ru_RU -fUTF-8</strong> и в файл <strong>/etc/default/locale</strong> добавляю</p>

<p><code>
LANG="ru_RU.UTF-8"
LC_CTYPE="ru_RU.UTF-8"
LC_NUMERIC=C
LC_TIME=C
LC_COLLATE=C
LC_MESSAGES=C
</code></p>

<p>Затем создаем пользователя, от лица которого мы и будем все делать и наделим его привилегиями запускать команды через sudo.</p>

<p><code>useradd -m -g staff -s /bin/bash deployer &amp;&amp; passwd deployer</code> &ndash; создаем пользователя deployer в группе staff (флаг -g) и с домашней папкой /home/deployer (флаг -m), флаг -s назначает пользоватлю шел по умолчанию. И задаем ему пароль. В дальнейшем весь экшн будет производиться от имени этого пользователя.</p>

<p>Чтобы наш пользователь мог выполнять команды от рута, необходимо добавить его в группу в файл <strong>/etc/sudoers</strong></p>

<p><code>
(%staff ALL=(ALL) ALL)
</code></p>

<p>Теперь выходим из под рута и логинимся под деплоером. Для того, чтобы не писать пароль каждый раз при входе, необходимо добавить на сервер инфо, что мы свои (авторизация по ключу).</p>

<p><code>cat ~/.ssh/id_rsa.pub | ssh deployer@server "mkdir ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys"</code></p>

<p>Если у кого на рабочей машине ubuntu, то они могут запустить эту операцию намного проще (ssh-copy-id deployer@server).</p>

<p>Проверяем, ssh deployer@server более не должно спрашивать пароль, а сразу же пустить нас на сервер.</p>

<p>Для удобства можно добавить в файл <strong>~/.ssh/config</strong>, чтобы удобно было заходить, печатая только <strong>ssh my_serv</strong></p>

<p>```
Host my_serv
  HostName server.com$
  User deployer$</p>

<p>```</p>

<p><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade</code> &ndash; обновляем все источники приложений и накатываем обновления</p>

<h3>Установка и базовая настройка Postgres'а</h3>

<p><code>sudo apt-get install postgresql libpq-dev</code> (второй пакет нужен для того, чтобы гем pg поставился)</p>

<p>Данная установка подразумевает, что вы не собираетесь соединяться с базой данных с других машин. По умолчанию в Ubuntu, Postgresql сконфигурирован так, чтобы использовать логин текущего пользователя, т.е. если вы вошли под пользователем deployer и в Postgresql есть пользователь deployer, то спрашивать пароль у вас никто не будет.</p>

<p><code>sudo -u postgres createuser --superuser $USER</code> (создаем пользователя deployer, который будет являться суперпользователем, этого делать не желательно, если у вас более, чем один проект, лучше под каждую бд создать отдельных пользователей с разными паролями)</p>

<p><code>sudo -u postgres psql</code> &ndash; запускаем postgres консоль</p>

<p>postgres=# \password deployer &ndash; задаем пароль для нашего пользователя (имя пользователя заменить на свое) &ndash; этот пароль будет использоваться в конфигах вашего приложения (config/database.yml)</p>

<p><code>createdb $USER</code> &ndash; создаем базу данных deployer</p>

<h3>Ставим rbenv, ruby и gem bundler</h3>

<p>Ставим все необходимое, чтобы склонировать репозиторий rbenv, установить последние ruby и пользоваться загрузкой картинок в наших приложениям (последние два пакета).</p>

<p><code>sudo apt-get install build-essential bison openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libxml2-dev libxslt1-dev autoconf libc6-dev libncurses5-dev libmagickcore-dev imagemagick</code></p>

<p>Теперь давайте перейдем к установки ruby с помощью rbenv и ruby-build. Здесь нет ничего не обычного, в основном все взято со страниц README rbenv и ruby-build.</p>

<h5>rbenv</h5>

<p><code>git clone git://github.com/sstephenson/rbenv.git ~/.rbenv</code></p>

<p><code>echo 'export PATH="$HOME/.rbenv/bin:$PATH"' &gt;&gt; ~/.bash_profile</code> &ndash; для доступа к команде rbenv</p>

<p><code>echo 'eval "$(rbenv init -)"' &gt;&gt; ~/.bash_profile</code> &ndash; для доступа к бинарникам установленных гемов и автокомплиту rbenv команд</p>

<p><code>exec $SHELL</code> &ndash; перезапускам шел</p>

<h5>ruby-build &ndash; для простой загрузки и сборки ruby из исходников</h5>

<p><code>git clone git://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build</code></p>

<p>устанвливаем ruby <code>rbenv install 1.9.3-p392</code> (для этого необходимо немало времени, поэтому наберитесь терпения, на машине с 512 оперативы эта операция занимает около 7 минут)</p>

<p>Пока приложение настраивается можно добавить пару строк в ~/.gemrc файл, для того, чтобы не устанавливать документацию вместе с гемами</p>

<p>install: &mdash;no-ri &mdash;no-rdoc
update: &mdash;no-ri &mdash;no-rdoc</p>

<p>после этого <code>rbenv global 1.9.3-p392</code> и <code>gem install bundler</code></p>

<h3>Локальное приложение для деплоя</h3>

<p>Теперь давайте подготовим наше локальное приложение (я для
этих целей создал простое приложение rails</p>

<p><code>rails new simple_deployment -T</code></p>

<p><code>rails g scaffold item name description:text</code> &ndash; для того, чтобы проверить и соединение с базой данных.</p>

<p>создадим файл .rbenv-version (<code>echo '1.9.3-p392' &gt; .rbenv-version</code>) для того, чтобы unicorn запускал необходимую версию ruby</p>

<p>также добавим в Gemfile gem unicorn и gem capistrano (последний в группу :development)</p>

<p>``` ruby
gem &lsquo;unicorn&rsquo;</p>

<p>group :development do</p>

<pre><code>gem 'capistrano'
</code></pre>

<p>end</p>

<p>```</p>

<p>и запустим в консоли <code>capify .</code> (capistrano создаст для нас файлик config/deploy.rb, который и будет &ldquo;пультом управления&rdquo; нашего приложения на сервере)</p>

<p><strong>config/deploy.rb</strong></p>

<p>``` ruby</p>

<p>require &lsquo;bundler/capistrano&rsquo;
load &lsquo;deploy/assets&rsquo;</p>

<p>set :repository, &lsquo;YOUR_GIT_OR_SVN_REPOSITORY_URL&rsquo;
set :scm, :git</p>

<p>server &lsquo;YOUR_SERVER_IP_OR_HOSTNAME&rsquo;, :app, :web, :db, :primary => true</p>

<p>set :ssh_options, { :forward_agent => true }
default_run_options[:shell] = &lsquo;bash -l&rsquo;</p>

<p>set :user, &lsquo;deployer&rsquo;
set :group, &lsquo;staff&rsquo;
set :use_sudo, false
set :rails_env, &lsquo;production&rsquo;</p>

<p>set :project_name, &lsquo;simple_deployment&rsquo;</p>

<p>set :deploy_to, &ldquo;/home/deployer/projects/#{ project_name }&rdquo;</p>

<p>desc &ldquo;Restart of Unicorn&rdquo;
task :restart, :except => { :no_release => true } do
  run &ldquo;kill -s USR2 <code>cat /home/deployer/projects/#{ project_name }/shared/pids/unicorn.pid</code>&rdquo;
end</p>

<p>desc &ldquo;Start unicorn&rdquo;
task :start, :except => { :no_release => true } do
  run &ldquo;cd #{current_path} ; bundle exec unicorn_rails -c config/unicorn.rb -D -E #{ rails_env }&rdquo;
end</p>

<p>desc &ldquo;Stop unicorn&rdquo;
task :stop, :except => { :no_release => true } do
  run &ldquo;kill -s QUIT <code>cat /home/deployer/projects/#{ project_name }/shared/pids/unicorn.pid</code>&rdquo;
end</p>

<p>after &lsquo;deploy:finalize_update&rsquo;, &lsquo;deploy:symlink_db&rsquo;</p>

<p>namespace :deploy do
  desc &ldquo;Symlinks the database.yml&rdquo;
  task :symlink_db, :roles => :app do</p>

<pre><code>run "ln -nfs #{deploy_to}/shared/config/database.yml #{release_path}/config/database.yml"
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Проекты у нас на сервере будут жить в домашнией папке + projects, т.е. для нашего пользователя deployer это будет /home/deployer/projects.</p>

<p>В каждой папке приложения находятся еще три папки (releases &ndash; где хранятся все релизы нашего приложения, current &ndash; симлинк на текущий релиз из папки releases и shared, где хранится общая шняга для все релизов: пиды, идентификаторы сессий, логи и прочее.)</p>

<p>Также необходимо добавить ssh ключ сервера на github или bitbucket</p>

<p>содержимое ключа <code>cat ~/.ssh/id_rsa.pub</code>, если такого файла нет, то нужно его сгенерировать <code>ssh-keygen -t rsa</code></p>

<p>и сделать с сервера <code>ssh git@bitbucket.org</code>, чтобы подтвердить соединение.</p>

<h5>config/unicorn.rb &ndash; минимальный конфиг для нашего HTTP сервера.</h5>

<p>``` ruby
worker_processes 2
user &lsquo;deployer&rsquo;, &lsquo;staff&rsquo;
preload_app true
timeout 30</p>

<p>project_name = &lsquo;simple_deployment&rsquo;</p>

<p>working_directory &ldquo;/home/deployer/projects/#{ project_name }/current&rdquo;</p>

<p>listen &ldquo;/tmp/#{ project_name }.socket&rdquo;, :backlog => 64
pid &ldquo;/home/deployer/projects/#{ project_name }/shared/pids/unicorn.pid&rdquo;</p>

<p>stderr_path &ldquo;/home/deployer/projects/#{ project_name }/shared/log/unicorn.stderr.log&rdquo;
stdout_path &ldquo;/home/deployer/projects/#{ project_name }/shared/log/unicorn.stdout.log&rdquo;
```</p>

<p>Если вы указали все верно в config/deploy.rb, то можно запустить <strong>cap deploy:setup</strong> для создания capistrano необходимых для разворачивания приложения папок на стороне сервера.</p>

<h3>Nginx</h3>

<p>Устанвливаем nginx командой <code>sudo apt-get install nginx</code> и переходим к его настройке. Для начала отредактируем файл <strong>/etc/nginx/nginx.conf</strong></p>

<p>```
user deployer staff;
worker_processes 2;</p>

<p>pid /var/run/nginx.pid;
events {
  worker_connections 1024;
  multi_accept on;
}</p>

<p>http {
  sendfile on;
  tcp_nopush on;
  tcp_nodelay off;</p>

<p>  include /etc/nginx/mime.types;
  default_type application/octet-stream;
  access_log /var/log/nginx/access.log;
  error_log /var/log/nginx/error.log;</p>

<p>  gzip on;
  gzip_disable &ldquo;msie6&rdquo;;
  gzip_proxied any;
  gzip_min_length 500;
  gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</p>

<p>  include /etc/nginx/conf.d/<em>.conf;
  include /etc/nginx/sites-enabled/</em>;
}</p>

<p>```</p>

<p>Последняя строчка нужна, чтобы nginx загружал свои конфиги и из папка <strong>/etc/nginx/sites-enabled/</strong> (это нужно для того, чтобы не хранить все конфиги для проектов в одном файле).</p>

<p>А теперь nginx конфиг для нашего приложения.Будем считать, что наше приложение называется simple_deployment, а домен у него simple-deployment.com (чтобы вам удобнее было заменять на свои данные).</p>

<p>```
upstream simple_deployment {
  server unix:/tmp/simple_deployment.socket fail_timeout=0;
}</p>

<p>server {
  server_name simple-deployment.com;
  root /home/deployer/projects/simple_deployment/current/public;
  access_log /var/log/nginx/simple_deployment_access.log;
  rewrite_log on;</p>

<p>  location / {</p>

<pre><code>proxy_pass http://simple_deployment;
proxy_redirect off;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

client_max_body_size 10m;
client_body_buffer_size 128k;

proxy_connect_timeout 90;
proxy_send_timeout 90;
proxy_read_timeout 90;
proxy_buffer_size 4k;
proxy_buffers 4 32k;
proxy_busy_buffers_size 64k;
proxy_temp_file_write_size 64k;
</code></pre>

<p>  }</p>

<p>  location ~ ^/(assets|images|javascripts|stylesheets|system)/ {</p>

<pre><code>root /home/deployer/projects/simple_deployment/current/public;
expires max;
break;
</code></pre>

<p>  }
}
```</p>

<p>и удалить файлы <strong>/etc/nginx/sites-available/default</strong> и <strong>/etc/nginx/sites-enabled/default</strong></p>

<p>Теперь можно смело пробовать запускать <code>cap deploy:migrations</code>  в консоли локального приложения. Если все было выполнено по данной заметке, то вы должны получить развернутое приложения на сервере в папке <strong>/home/deployer/projects/simple_deployment</strong>, если вы конечно строго следовали инструкциям.</p>

<p>Запустим последную команду на сервере, запустим nginx (<code>sudo service nginx start</code>).</p>

<p>Теперь, после деплоя можно запускать команду cap start или cap stop для запуска сервера или его остановки. Надеюсь, следуя этому мануалу, у вас получилось развернуть свое приложение на сервере. Если нет, то милости прошу в комментарии, чем смогу, постараюсь помочь.</p>

<p>Ссылки на дополнительные материлы:</p>

<ul>
<li><a href="http://gembundler.com/deploying.html">деплой вместе с bundler</a></li>
<li><a href="http://unicorn.bogomips.org/Unicorn/Configurator.html">конфигурация unicorn'а</a></li>
</ul>


<p>Enjoy, my little colleagues :)</p>

<p>UPDATE: 06.03.2013
Немного защитим наш сервер, в первую очередь давайте запретим логин рута по ssh, у нас на это есть пользователь deployer, который может выполлнять команды от рута с помощью sudo. Для этого в файле <strong>/etc/ssh/sshd_config</strong> необходимо изменить
<strong>PermitRootLogin</strong> на <strong>no</strong> и <strong>PasswordAuthentication</strong> на <strong>no</strong>, последняя настройка запретит авторизацию для SSH по паролю (только по ключу).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Оповещение после выполнения "тяжелой" фоновой задачи с помощью faye и PrivatePub]]></title>
    <link href="http://vredniy.github.io/2013/01/resque-with-private-pub-and-rails"/>
    <updated>2013-01-21T22:45:24+04:00</updated>
    <id>http://vredniy.github.io/2013/01/resque-with-private-pub-and-rails</id>
    <content type="html"><![CDATA[<p>Допустим нам необоходимо после выполнения большой задачи в фоновом режиме сообщить об этом пользователю и совершить что-нибудь, например, показать ему какой-нибудь popup. <!-- more -->
Для этого по-старинке, можно с интервалом, скажем в 1 секунду опрашивать сервер и смотреть не завершилась ли наша задача, но в пору HTML5  делать это, по крайней мере, не престижно. Будем использовать для этих целей инструмент по обмену сообщениями между сервером и клиентом <strong>Faye</strong>.</p>

<h3>Инструменты</h3>

<p>Нам понадобится Rails приложение, к которому мы и будем привязывать всю эту функциональность. Также будем использовать <strong>Resque</strong> для выполнений фоновых задач &ndash; инструмент, зарекомендовавший себя, как надежный и стабильный помощник, спасающий всегда, когда нужно выполнить тяжелые задачи в фоне. Вместе с <strong>faye</strong> воспользуемся оберткой для него от Ryan Bates <strong>Private Pub</strong>, который мне очень облегчил жизнь, надеюсь, и облегчит вам.</p>

<h3>Реализация</h3>

<p>Для начала установим redis и обновим наш Gemfile, дополнив его необходимыми гемами resque, faye, private_pub, thin.</p>

<p>Я буду рассказать все на примере Mac OS, установка подобного инструментарий, скажем, на Ubuntu, не должна вызвать вопросов, потому что инструменты очень распространенные.</p>

<p>Устанавливал redis я с помощью всем известного пакетного менеджера Homebrew, напечатав в терминале всего одну команду <code>brew install redis</code></p>

<p>Допустим у нас имеется какой-нибудь тяжелый объект с несколькими картинками, которые лежат в Amazon S3 и, чтобы создать копию этого объекта нам понадобится скачать все эти картинки, чтобы вновь их туда загрузить,  привязав в новому объекту. Не спрашивайте почему так сложно, так работает CarrierWave или я просто не нашел лучшего решения.</p>

<p>Если у нас раньше был метод в контролле, к примеру, clone, которй вызывал метод из модели, делающий всю грязную работу, то сейчас нам нужно лишь добавить новую задачу для resque, выглядеть это будет примерно так</p>

<p><code>ruby
def clone
  Resque.enqueue(CloneProfileWorker, params[:id])
end
</code></p>

<p>Теперь тяжелая задача будет добавляться в очередь всякий раз, когда мы пройдем по ссылке <strong>/profiles/#{ id }/clone</strong>.</p>

<p>Давайте поставим и настроим PrivatePub, который будет со стороны клиента подписываться на определенные события, и со стороны сервера, после наступления определенного события (в нашем примере это, когда resque job отработает) делать нужные нам вещи.</p>

<p>Для этого в консоли нужно запустить <code>rails g private_pub:install</code></p>

<p>и добавить в файл app/assets/javascripts/application.js[.cofeee] строчку
<code>#= require private_pub</code>, если вы используете cofeeScript или же <code>//= require private_pub</code>, если js</p>

<p>и дальше во вьюхе <strong>/profile/clone.html.haml</strong> (я использую haml в данном проекте)</p>

<p>``` ruby
= subscribe_to &ldquo;/profile_cloning_#{ params[:id] }&rdquo;</p>

<p>:javascript
  PrivatePub.subscribe(&lsquo;/profile_cloning_#{ params[:id] }&rsquo;, function(data, channel) {</p>

<pre><code>location.href = data.url;
</code></pre>

<p>  });</p>

<p>```</p>

<p>Первая строчка это метод из гема, который инициализует объект необходимыми параметрами из файла /config/private_pub.yml, а после мы &ldquo;подписываемся на событие &lsquo;/profile_cloning_#{ params[:id] }&rsquo;, где в params[:id] содержится текущий id профиля. При наступлении данного события, мы перенаправляем пользователя на страницу &lsquo;/profile/#{ new_id }/edit&rdquo;, полный урл мы получим после того, как resque job отработает.</p>

<p><strong>app/workers/clone_profile_worker.rb</strong></p>

<p>``` ruby
require &lsquo;resque&rsquo;</p>

<p>class CloneProfileWorker
  @queue = :default</p>

<p>  def self.perform(profile_id)</p>

<pre><code>c = Profile.find profile_id
new_profile = c.clone_self

if new_profile.is_a? Profile
  PrivatePub.publish_to "/profile_cloning_#{ profile_id }", :url =&gt; "/profiles/#{ new_profile.id }/edit"
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>В данном воркере нет ничего магического: сначала мы клонируем наш профиль и если все прошло успешно, то оповещаем нашего клиента и передаем туда url, на который он перенаправится.</p>

<p>Проверяем работоспособность</p>

<p>Запускаем в разных окнах терминала:</p>

<ul>
<li><code>rails s</code></li>
<li><code>redis-server /usr/local/etc/redis.conf</code> (у меня MacOs, на других ОС должно быть нечто подобное)</li>
<li><code>VERBOSE=1 rake resque:work QUEUE=*</code> (запускаем все очереди, устанвливаем verbose=1 для того, чтобы видеть что происходит внутри resque)</li>
<li><code>rackup private_pub.ru -s thin -E production</code> (сервер для PrivatePub и Faye)</li>
</ul>


<p>Проходим по ссылке наподобие <strong>/profiles/73/clone</strong> и смотрим в терминале как отрабатывает наш resque job и мы перенаправляемся на редактирование уже склонированного профиля, если все отработало без ошибок. Если же возникли ошибки, то они отобразятся в терминале, если произойдет что-то невообразимое и непредвиденное, пишите в комментариях, я попробую помочь вам.</p>
]]></content>
  </entry>
  
</feed>
