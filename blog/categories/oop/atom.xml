<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: OOP | Записки Вредного программиста]]></title>
  <link href="http://zudochkin.ru/blog/categories/oop/atom.xml" rel="self"/>
  <link href="http://zudochkin.ru/"/>
  <updated>2014-02-03T21:38:05+04:00</updated>
  <id>http://zudochkin.ru/</id>
  <author>
    <name><![CDATA[Зудочкин Дима]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Покерный класс на PHP]]></title>
    <link href="http://zudochkin.ru/2011/08/poker-class-php"/>
    <updated>2011-08-11T13:52:41+04:00</updated>
    <id>http://zudochkin.ru/2011/08/poker-class-php</id>
    <content type="html"><![CDATA[<p>Приветствую тебя, разработчик или случайно зашедший на огонек в этот уютный технический бложек. Сегодня речь пойдет о несколько математической задаче, хоть и немного там математики, да и она понятна школьнику 5го класса. Сегодня мы научимся распознавать комбинации в Техасском холдеме, именно в такую разновидность покера я играю (играл). Т.к. это очень простой класс на PHP, он не будет иметь определять старшинство одинаковых по названию комбинаций, но разнящихся по номиналу, к примеру стрит до 10 и стрит до 8 будут трактоваться этим классом, как просто стрит. В Техасском холдеме всего 10 комбинаций и мы с вами пройдемся от самой старшей из них &ndash; флеш рояль до самой младшей &ndash; старшая карта.</p>

<!-- more -->


<h6>Флеш рояль</h6>

<p>Высшая кобинация в покере &ndash; это стрит (стрейт) флеш до туза.</p>

<p>``` php
protected function _isRoyalFlush()
{</p>

<pre><code>return ($this-&gt;_isFlush() &amp;&amp; $this-&gt;_isStraight() &amp;&amp; array_search(14, $this-&gt;_ranks) &amp;&amp; array_search('13', $this-&gt;_ranks));
</code></pre>

<p>}
```</p>

<p><img class="image" src="/images/posts/2011-08-poker-class-php/poker-class-php-300x214.jpg"></p>

<p>Немного костыльный способ проверки на флеш рояль: проверяем на наличие стрита, флеша и чтобы наличствовали туз и кароль.</p>

<h6>Каре или Quad</h6>

<p>Тут проще некуда, нужно наличие четырех одинаковых карт.</p>

<p>``` php
protected function _isQuad()
{</p>

<pre><code>$test = $this-&gt;_ranks;

$uniqueElementsCount = array();

foreach($this-&gt;_ranks as $key =&gt; $card) {
    $test = $this-&gt;_ranks;
    unset($test[$key]);
    $uniqueElementsCount[] = count(array_unique($test));
}


return 1 === min($uniqueElementsCount);
</code></pre>

<p>}
```</p>

<h6>Стрит флеш</h6>

<p>Тот же самый флешрояль, только необязательно, чтобы стрит был до туза (10-валет-дама-кароль-туз).</p>

<p>``` php
protected function _isStraightFlush()
{</p>

<pre><code>return ($this-&gt;_isFlush() &amp;&amp; $this-&gt;_isStraight());
</code></pre>

<p>}
```</p>

<h6>Фул хаус</h6>

<p>Это когда три карты одного достоинства и две другого. Не самая удачная реализация :)</p>

<p>``` php
protected function _isFullHouse()
{</p>

<pre><code>$ranks = $this-&gt;_ranks;
sort($ranks);

if ((($ranks[0] == $ranks[1] &amp;&amp; $ranks[1] == $ranks[2]) &amp;&amp; ($ranks[3] == $ranks[4])) // 1=2=3 and 4=5
        || ($ranks[0] == $ranks[1]) &amp;&amp; ($ranks[2] == $ranks[3] and $ranks[3] == $ranks[4])) // 1=2 and 3=4=5
    return true;

return false;
}
</code></pre>

<p>```</p>

<h6>Флеш</h6>

<p>Все карты в комбинации должны быть одной масти. Проверяет все очень просто: сортируется массив с мастями и проверяется на равенство первая и последняя карты.</p>

<p>``` php
protected function _isFlush()
{</p>

<pre><code>$suits = $this-&gt;_suits;
sort($suits);
if ($suits[0] === $suits[4])
    return true;

return false;
</code></pre>

<p>}
```</p>

<h6>Стрит</h6>

<p>Вне зависимости от масти, достоинство карт должно быть по старшенству (5 подряд). Из-за того, что туз может в зависимости от ситуации быть и самой старшей, и самой младшей картой, пришлось сделать две проверки.</p>

<p>``` php
protected function _isStraight()
{</p>

<pre><code>$ranks = $this-&gt;_ranks;
sort($ranks);

// if Ace is low card in straight
if ($key = array_search(14, $ranks)) {
    $tempRanks = $ranks;
    unset($tempRanks[$key]);
    if (array(2, 3, 4, 5) == $tempRanks) {
        return true;
    }
    unset($tempRanks);
}

// if Ace is high card - default algorithm
$min = $ranks[0];
foreach($ranks as $key =&gt; $value) {
    $ranks[$key] -= $min;
    if ($key != $ranks[$key])
        return false;
}
return true;
</code></pre>

<p>}
```</p>

<h6>Сет, трипс или тройка</h6>

<p>Нужно наличие трех одинаковых карт. Алгоритм опять же далек от совершенства, но он выполняет свою работу.</p>

<p>``` php
protected function _isThreeOfKind()
{</p>

<pre><code>$ranks = $this-&gt;_ranks;
sort($ranks);

if (($ranks[0] == $ranks[1] and $ranks[1] == $ranks[2])
        || ($ranks[1] == $ranks[2] and $ranks[2] == $ranks[3])
        || ($ranks[2] == $ranks[3] and $ranks[3] == $ranks[4]))
    return true;
return false;
</code></pre>

<p>}
```</p>

<h6>Две пары</h6>

<p>Из название алгоритма должно быть понятно что к чему.</p>

<p>``` php
protected function _isTwoPairs()
{</p>

<pre><code>$ranks = $this-&gt;_ranks;

foreach($ranks as $key =&gt; $rank) {
    $testRanks = $ranks;
    unset($testRanks[$key]);
    sort($testRanks);
    if (($testRanks[0] == $testRanks[1])
            and ($testRanks[2] == $testRanks[3])
            and ($testRanks[0] != $testRanks[2])
            // exclude full house
            and ($testRanks[0] != $ranks[$key])
            and ($testRanks[2] != $ranks[$key])
    )
        return true;
}
return false;
</code></pre>

<p>}
```</p>

<h6>Пара</h6>

<p>Количество уникальных карт из пяти должно равняться четырем, если опять же я ничего не перепутал :).</p>

<p>``` php
protected function _isPair()
{</p>

<pre><code>return 4 === count(array_unique($this-&gt;_ranks));
</code></pre>

<p>}
```</p>

<h6>Старшая карта</h6>

<p>Последний абзаци больше для красоты, потому что если ни одна комбинация не подошла, значит комбинация &ndash; старшая карта.</p>

<p>``` php
protected function _isHighCard()
{</p>

<pre><code>return true;
</code></pre>

<p>}
```</p>

<h6>Исходный код класса для опеределения покерных комбинаций на PHP</h6>

<p>``` php
&lt;?php
/<strong>
 * @author vredniy.ru
 *
</strong>/
class Poker
{</p>

<pre><code>protected $_cards = array();
//
protected $_ranks = array();
protected $_suits = array();

public function __construct(array $cards)
{
    $this-&gt;_cards = $cards;

    $rank = null;

    foreach($cards as $card) {
        switch (strtolower($card['rank'])) {
            case 't':
                $rank = 10;
                break;
            case 'j':
                $rank = '11';
                break;
            case 'q':
                $rank = '12';
                break;
            case 'k':
                $rank = '13';
                break;
            case 'a':
                $rank = '14';
                break;
                ;
            default:
                $rank = $card['rank'];
                break;
        }
        $this-&gt;_ranks[] = $rank;
        $this-&gt;_suits[] = $card['suit'];
    }
}

public function checkCombination()
{
    // is Royal Flush
    echo $this-&gt;_isRoyalFlush() ? 'royal flush' : 'not royal flush';
    echo '&lt;br&gt;';

    // is Quad (four of kind)
    echo $this-&gt;_isQuad() ? 'quad' : 'not quad';
    echo '&lt;br&gt;';

    // is StraightFlush
    echo $this-&gt;_isStraightFlush() ? 'straight flush' : 'not straight flush';
    echo '&lt;br&gt;';

    // is Full House
    echo $this-&gt;_isFullHouse() ? 'full house' : 'not full house';
    echo '&lt;br&gt;';

    // is Flush
    echo $this-&gt;_isFlush() ? 'flush' : 'not flush';
    echo '&lt;br&gt;';

    // is Straight
    echo $this-&gt;_isStraight() ? 'straight' : 'not straigt';
    echo '&lt;br&gt;';

    // is Three of Kind
    echo $this-&gt;_isThreeOfKind() ? 'three of kind' : 'not three of kind';
    echo '&lt;br&gt;';

    // is Two Pairs
    echo $this-&gt;_isTwoPairs() ? 'two pairs' : 'not two pairs';
    echo '&lt;br&gt;';

    // is one Pair
    echo $this-&gt;_isPair() ? 'pair' : 'not pair';
    echo '&lt;br&gt;';

    // is High Card
    echo $this-&gt;_isHighCard() ? 'high card' : 'not high card';
    echo '&lt;br&gt;';
}

/**
 * chech that combination is flush and straight and contains ace and king (exclude straight flush "ace-5")
 *
 * @return bool
 */
protected function _isRoyalFlush()
{
    return ($this-&gt;_isFlush() &amp;&amp; $this-&gt;_isStraight() &amp;&amp; array_search(14, $this-&gt;_ranks) &amp;&amp; array_search('13', $this-&gt;_ranks));
}

/**
 * check combination is quad (four of kind)
 *
 * @return bool
 */
protected function _isQuad()
{

    $test = $this-&gt;_ranks;

    $uniqueElementsCount = array();

    foreach($this-&gt;_ranks as $key =&gt; $card) {
        $test = $this-&gt;_ranks;
        unset($test[$key]);
        $uniqueElementsCount[] = count(array_unique($test));
    }


    return 1 === min($uniqueElementsCount);
}

/**
 * is a straight and a flush?
 *
 * @return bool
 */
protected function _isStraightFlush()
{
    return ($this-&gt;_isFlush() &amp;&amp; $this-&gt;_isStraight());
}

/**
 * is full house?
 * (1=2=3 and 4=5) or (1=2 and 3=4=5)
 *
 * @return bool
 */
protected function _isFullHouse()
{
    $ranks = $this-&gt;_ranks;
    sort($ranks);

    if ((($ranks[0] == $ranks[1] &amp;&amp; $ranks[1] == $ranks[2]) &amp;&amp; ($ranks[3] == $ranks[4])) // 1=2=3 and 4=5
            || ($ranks[0] == $ranks[1]) &amp;&amp; ($ranks[2] == $ranks[3] and $ranks[3] == $ranks[4])) // 1=2 and 3=4=5
        return true;

    return false;
}

/**
 * is flush?
 *
 * @return bool
 */
protected function _isFlush()
{
    $suits = $this-&gt;_suits;
    sort($suits);
    if ($suits[0] === $suits[4])
        return true;

    return false;
}

/**
 * check straight. 2 attempt, 'cause ace may be high card, or low.
 *
 * @return bool
 */
protected function _isStraight()
{

    $ranks = $this-&gt;_ranks;
    sort($ranks);

    // if Ace is low card in straight
    if ($key = array_search(14, $ranks)) {
        $tempRanks = $ranks;
        unset($tempRanks[$key]);
        if (array(2, 3, 4, 5) == $tempRanks) {
            return true;
        }
        unset($tempRanks);
    }

    // if Ace is high card - default algorithm
    $min = $ranks[0];
    foreach($ranks as $key =&gt; $value) {
        $ranks[$key] -= $min;
        if ($key != $ranks[$key])
            return false;
    }
    return true;
}

/**
 * is Three of kind
 *
 * @return bool
 */
protected function _isThreeOfKind()
{
    $ranks = $this-&gt;_ranks;
    sort($ranks);

    if (($ranks[0] == $ranks[1] and $ranks[1] == $ranks[2])
            || ($ranks[1] == $ranks[2] and $ranks[2] == $ranks[3])
            || ($ranks[2] == $ranks[3] and $ranks[3] == $ranks[4]))
        return true;
    return false;
}

/**
 * is two pairs
 *
 * @return bool
 */
protected function _isTwoPairs()
{
    $ranks = $this-&gt;_ranks;

    foreach($ranks as $key =&gt; $rank) {
        $testRanks = $ranks;
        unset($testRanks[$key]);
        sort($testRanks);
        if (($testRanks[0] == $testRanks[1])
                and ($testRanks[2] == $testRanks[3])
                and ($testRanks[0] != $testRanks[2])
                // exclude full house
                and ($testRanks[0] != $ranks[$key])
                and ($testRanks[2] != $ranks[$key])
        )
            return true;
    }
    return false;
}

/**
 * is single Pair
 *
 * @return bool
 */
protected function _isPair()
{
    return 4 === count(array_unique($this-&gt;_ranks));
}

/**
 * is High Card
 *
 * @return bool true
 */
protected function _isHighCard()
{
    return true;
}
</code></pre>

<p>}
```</p>

<h6>Небольшой пример использования</h6>

<p>``` php
&lt;?php</p>

<p>require_once &lsquo;Poker.php&rsquo;;</p>

<p>$cards = array(</p>

<pre><code>array('suit' =&gt; 's', 'rank' =&gt; '3'),
array('suit' =&gt; 's', 'rank' =&gt; '7'),
array('suit' =&gt; 's', 'rank' =&gt; 'a'),
array('suit' =&gt; 's', 'rank' =&gt; 't'),
array('suit' =&gt; 's', 'rank' =&gt; 't')
</code></pre>

<p>);</p>

<p>$poker = new Poker($cards);</p>

<p>$poker->checkCombination();
```</p>

<p>Комбинация из 5 карт для данного класса задается массивом из 5 элементов, которые в свою очередь явлеются ассоциативными массивами (suit &ndash; это масть, rank &ndash; достоинство карты).</p>

<h3>Эпилог</h3>

<p>Данный класс можно немного доработать, чтобы вместо название комбинаций, он выводил какой-нибудь балл комбинации, чтобы имелась возможность сравнивать две одинаковых комбинации, но это по желанию и выходит за пределы данной заметки. Также вы можете допилить проверку на корректность заданной комбинации. На этом на сегодня все.  Удачи вам в любых начинаниях и продолжениях.</p>
]]></content>
  </entry>
  
</feed>
