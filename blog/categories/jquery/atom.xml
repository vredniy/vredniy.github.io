<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jQuery | Записки Вредного программиста]]></title>
  <link href="http://zudochkin.ru/blog/categories/jquery/atom.xml" rel="self"/>
  <link href="http://zudochkin.ru/"/>
  <updated>2014-02-03T21:38:05+04:00</updated>
  <id>http://zudochkin.ru/</id>
  <author>
    <name><![CDATA[Зудочкин Дима]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Полиморфная связь и TokenInput jQuery]]></title>
    <link href="http://zudochkin.ru/2012/04/polymorphic-relations-and-token-input-jquery"/>
    <updated>2012-04-18T23:26:02+04:00</updated>
    <id>http://zudochkin.ru/2012/04/polymorphic-relations-and-token-input-jquery</id>
    <content type="html"><![CDATA[<p>Представьте ситуацию, что у вас имеется некая модель, к которой вы хотите добавлять по средствам связей другие модели. Хорошо, когда данную связь можно описать обычным <strong>has_many</strong>, другое дело, когда нужно привязать разнородные модели, к примеру, у вас имеется модель вопросов, к которой нужно привязать город или страну <!-- more -->(не очень наглядный пример, вряд ли он вам в жизни встретится, но я поделюсь своим опытом).</p>

<p>Как вы, наверное, догадались, основным инструментом будет выступать ruby an rails. Из гемов будем использовать <strong>simple_form</strong> для удобного создания форм, <strong>inherited_resources</strong>, чтобы писать намного меньше кода в контроллерах (сейчас не представляю без этого гема жизни).</p>

<p>Также нам понадобится плагин для jQuery <a href="http://loopj.com/jquery-tokeninput/">tokenInput</a>, который будет отображать выпадающий список с autoComplete'ом, из которого мы сможем выбрать одно значение из стран или городов (список будет один).</p>

<h3>Реализация</h3>

<p>Начнем с контроллера <strong>QuestionableController</strong> (не очень, конечно, удачное название), который будет отдавать солянку из городов и стран с возможностю поиска.
``` ruby
class QuestionableController &lt; ApplicationController
  def index</p>

<pre><code>countries = Country.find(:all, conditions: ['name LIKE(?)', "%#{ params[:q]
cities = City.find(:all, conditions: ['name LIKE(?)', "%#{ params[:q] }%"])

@questionable = countries + cities

respond_to do |format|
  format.json { render }
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Лучше вынести всю логику в модель, но данный пример создан исключительно для демонстрации. Что мы делаем в этом контроллере? Ищем страны и города, удовлетворяющих параметру <strong>q</strong> и заполняем инстанс переменную <strong>@questionable</strong></p>

<p>Также давайте заполним нашу вьюшку <em>index.json.erb</em></p>

<p>``` ruby
&lt;%= sanitize @questionable.to_json(methods: [:id_with_class_name], only: [:id, :name]) %></p>

<p>```</p>

<p>в которой мы рендерим наш json, т.к. нам не нужны все поля модели мы используем только необходимые <code>(only: [:id, :name])</code>, ключ methods: указывает на то, что мы помимо физических свойст, будем использовать метод модели <em>id_with_class_name</em>.</p>

<p>Пока не забыл, давайте пропишем пару строк в наш <em>config/routes.rb</em></p>

<p><code>ruby
resources :questions # для того, чтобы создавать/показывать/удалять вопросы
resources :questionable, only: :index # для того, чтобы отображать json
</code></p>

<p>Перейдем к моделям:</p>

<p><em>models/question.rb</em>
``` ruby
class Question &lt; ActiveRecord::Base
  attr_accessor :location</p>

<p>  belongs_to :questionable, polymorphic: true
  attr_accessible :name, :questionable_id, :questionable_type</p>

<p>  before_save do</p>

<pre><code>return unless self.location =~ /_/
location_id, location_type = self.location.split('_')
self.questionable_id   = location_id   unless location_id.nil?
self.questionable_type = location_type unless location_type.nil?
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Самая интересная строчка &ndash; это та, которая начинается с <code>belongs_to</code>, в ней мы объявляем полиморфную связь questionable. Дальше идет метод, который мы вызываем каждый раз перед сохранением в базу данных. В нем мы парсим строку из autoComplete'а, которая будет иметь вид id_ModelName и сохраняем отдельно id и ModelName.</p>

<p>Модель <em>city.rb</em>
``` ruby
class City &lt; ActiveRecord::Base
  has_many :questions, as: :questionable
  attr_accessible :name</p>

<p>  def id_with_class_name</p>

<pre><code>"#{ id }_#{ self.class.name }"
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>В ней объявляется связь <code>has_many</code> через questionable, который мы обявили в модели question полиморфной. Далее идем метод, который возвращает id записи и название класса модели (чтобы можно было отделить зерно от плевел).</p>

<p>Модель <em>country.rb</em> почти такая же
``` ruby
class Country &lt; ActiveRecord::Base
  has_many :questions, as: :questionable
  attr_accessible :name</p>

<p>  def id_with_class_name</p>

<pre><code>"#{ id }_#{ self.class.name }"
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Связь обявлена также как и в предыдущей модели.</p>

<p>Наш маленький контроллер <em>QuestionController</em>
<code>ruby
class QuestionsController &lt; InheritedResources::Base
end
</code>
где остальное спросите вы. Это все. Это все, что нам нужно для того, чтобы создавать, удалять, редактировать вопросы. Как вы, наверное, заметили наш контроллер наследуется не от ApplicationController'а, а от inherited_resources. Что это значит? А это значит, если абстрагироваться от 80% возможностей этого гема, то, что гем берет всю &ldquo;грязную&rdquo; работу на себя, предоставляя нам в пользование переменные resource и collection, хранятся в которых ссылка на текущую запись (resource) и список всех записей (collection) соответственно. Для того, чтобы мы смогли создать свой первый вопрос нам необходимы лишь вьюшки. Начнем с _form.html.erb, которую мы будем подключать и в создании вопроса, и в редактировании.</p>

<p><em>app/views/questions/</em>form.html.erb_</p>

<p>``` ruby
&lt;%= simple_form_for resource do |f| %>
  &lt;% pre = if resource.questionable %></p>

<pre><code>&lt;% [resource.questionable].to_json(only: [:id, :name]) %&gt;
</code></pre>

<p>  &lt;% end %>
  &lt;%= f.input :name %>
  &lt;%= f.input :location, input_html: { &lsquo;data-pre&rsquo; => pre, class: &lsquo;token-input-questionable&rsquo; } %>
  &lt;%= f.submit nil %>
&lt;% end %></p>

<p>```</p>

<p>Как видите, почти никаких различий с нативным form_for нет. Во второй строке мы заполняем переменную pre json'ом выбранного города или страны, в предпоследней создаем инпут с атрибутом data-pre, равным json'у и классом, чтобы мы могли найти этот элемент без проблем.</p>

<p><em>new.html.erb</em> и <em>edit.html.erb</em> абсолютно одинаковы и представляют собой следующее:</p>

<p><code>ruby
&lt;%= render 'form' %&gt;
</code></p>

<p>в них мы отрисовываем только форму.</p>

<p>Далее кинем наш скачанный jquery.tokeninput.js в папку <em>app/assets/javascripts</em> и допишем в <em>application.js</em> следующее:</p>

<p>``` javascript
$(function() {
  var $input = $(&lsquo;.token-input-questionable&rsquo;);
   $input.tokenInput(&lsquo;/questionable.json&rsquo;, {</p>

<pre><code>  tokenLimit: 1,
  tokenValue: 'id_with_class_name',
  prePopulate: $input.data('pre')
});
</code></pre>

<p>});</p>

<p>```</p>

<p>Первым параметром к tokenInput мы указываем откуда брать данные, tokenLimit:1 указывает на то, что одной записи нам будет достаточно (одного элемента из выпадающего списка), tokenValue &ndash; откуда мы будем брать имя, которое будем отображать из json'а, prePopulate используем для того, чтобы заполнить элемент, если мы его уже выбрали (редактирование).</p>

<p><img class="image" src="/images/posts/2012-04-polymorphic-relations-and-token-input-jquery/rsz_1screenshot_from_2012-04-18_230555-300x209.png"></p>

<p>Сумбурным получилось изложения материала, потому что для меня это в новинку и писалось это для того, чтобы не забыть полезную &ldquo;плюшку&rdquo; в дальнейшем. Если заметка кому-нибудь еще пригодится, я буду очень рад :)</p>

<p>P.S.: Если данную заметку читает Александр, мало ли, то, надеюсь, он будет не против, что я позаимствовал его идею :)</p>

<p>Демо проект &ldquo;лежит&rdquo; на <a href="http://vredniy-polymorphic.heroku.com/questions/">heroku</a>, репозиторий, как всегда на <a href="https://github.com/vredniy/rails-token-input">github</a> (там же лежат и миграции, нужные для запуска проекта).</p>

<p>Удачи вам в любых начинаниях и до новых встреч :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backbone.js и Sinatra (Ruby)]]></title>
    <link href="http://zudochkin.ru/2012/02/backbone-js-sinatra-ruby"/>
    <updated>2012-02-11T23:58:01+04:00</updated>
    <id>http://zudochkin.ru/2012/02/backbone-js-sinatra-ruby</id>
    <content type="html"><![CDATA[<p>Приветствую тебя, товарищ-разработчик, сегодня речь пойдет больше о клиентсом программировании, точнее об одном фреймворке. Backbone js ему название. Что в нем особенного спросите вы. Это первый MVC фреймворк на стороне клиента, попавшийся мне на глаза. Очень долго я с ним воевал, поэтому тут уж дело чести понять как работают 1200 строк кода на javascript.</p>

<!-- more -->


<p>Данная заметка не прендует на всеобъемлющее описание, да и практической пользы от разрабатываемого в ней приложения (без доработки) практически нет, это больше для души или, как говорится, for fun.</p>

<p>Сначала поставим себе небольшую цель, чего же мы хотим увидеть по окончании: одна страница, без ссылок и переходов, все взаимодействие с сервером происходит в режиме реального времени по средством ajax запросов. В конце мы сможем добавлять новые книги, удалять их и изменять поля. Весь &ldquo;дизайн&rdquo; выполнен человеком, то бишь мною, ничего общего с дизайнерами и верстальщиками не имеющего, но, как мне кажется, он [дизайн], получился удобным и не отталкивающим. Обрабатывать наши ajax запросы будет Ruby при помощи замечательного фреймворка Sinatra, но работа им предстоит не сложная, поэтому сосредоточимся на frontend'е.</p>

<h3>Что еще за backbone.js?</h3>

<p>Аналог jquery? Нет, у данного фреймворка совсем другая специализация &ndash; его основная задача создать основу для модульного приложения на стороне клиента, чтобы богатые на компоненты и модули интерфейсы легко могли взаимодействовать с пользователем. Чтобы добавления новой функциональности не превращало код приложения в спагетти, а наоборот, этому способствовало.</p>

<h3>Из чего состоит backbone.js?</h3>

<p>Модель, Представление, Коллекция и Роутер, если не сильно вдаваться в подробности (очень хорошая документация собрана на сайте backbone.js), то модель представляет собой, если проводить аналогию с базами данных, строку в таблице, к любым свойствам которой мы легко можем обращаться, также легко мы можем ее обновлять, сохранять и прочее. Коллекция &ndash; кучка моделей или по аналогии &ndash; несколькими строками таблицы, объединенных общими полями и свойствами. Представление &ndash; вот это, по-моему, самая интересная и в то же время непростая для меня часть. Представление в понимании создателей backbone.js &ndash; это совсем иное, нежели мы, backend-разработчики привыкли видеть. Это что-то очень похожее на букву V из аббревиатуры MVC, но с немного большими возможностями и ответственностями. Я думаю на примере станет немного яснее. И последним будет Роутер &ndash; в данном приложении я его использовать не буду, оно слишком маленькое, чтобы усложнять его и без того не простую к пониманию новую технологию, по крайней мере, для меня. Как написано на сайте backbone.js роутер предоставляет методы для связывания ссылок на странице со всевозможными событиями. С появлением в нашей жизни History API, появилась возможность использовать наряду с ссылками вида /#about, ссылки обычного вида, /about, к примеру, что намного приятнее для глаза человеческого.</p>

<p><img class="image" src="/images/posts/2012-02-backbone-js-sinatra-ruby/backbone-sinatra.jpeg"></p>

<p>Итак, хватит воды, давайте приступим к делу. Начнем, конечно же с html, который и будет подключать все библиотеки стили на стороне клиента, в нем же будем хранить наш шаблон, что для маленького приложения не будет грубой ошибкой.</p>

<p>``` html</p>

<script type="text/javascript" src="js/jquery-1.7.1.js"></script>


<script type="text/javascript" src="js/underscore.js"></script>


<script type="text/javascript" src="js/backbone.js"></script>


<p><link rel="stylesheet" type="text/css" href="styles/bootstrap.css">
<link rel="stylesheet" type="text/css" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/hot-sneaks/jquery-ui.css">
<link rel="stylesheet" type="text/css" href="styles/main.css"></p>

<script type="text/javascript" src="js/bootstrap.js"></script>


<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js"></script>


<script type="text/javascript" src="js/jquery.ui.datepicker-ru.js"></script>


<!--<script type="text/javascript" src="js/backbone.localStorage.js"></script>-->


<p>```</p>

<p>Начнем с подключения библиотеки и стилей: за основу взят, уже не в первый раз css фреймворк bootstrap от twitter, в самом начале подключаем нашу любимую библиотеки <a href="/category/jquery">Query</a>, но backbone.js может работать и без нее, это больше для нас, чтобы вместо 5 строк не писать 50 :). underscore.js &ndash; библиотека-утилита, которая предоставляет основу для функционального программирования на JavaScript, без него не работает наш backbone.js, поэтому подключайте underscore.js раньше. Остальные библиотеки не должны вызвать сложностей в понимании: они уже у всех на слуху, отдельно коснусь закомментированной строки. Если ее расскомментировать и внести небольшие изменения в код, то вместо хранения всего в базе данных, мы будем использовать localStorage браузера, который это поддерживает.</p>

<p>Теперь немного разметки,</p>

<p>``` html</p>

<div class="container-fluid" id="books">
  <div class="row-fluid">
   <div class="span12">
      <h1>Моя библиотека</h1>
   </div>
  </div>
  <div class="row-fluid">
    <div class="span2">
      <div id="book-control">
         <!-- добавление новых книг -->
         <h3>Добавить</h3>

      <label for="book-title">Название книги</label>
      <input type="text" id="book-title" class="span12">
      <button class="btn-primary">Добавить новую</button>

   </div>
    </div>
    <div class="span8 book-container">
      <!-- место для книг -->
    </div>
    <div class="span2">
      <h3>Описание</h3>
    </div>
  </div>
</div>


<p>```</p>

<p>Здесь ничего особенного, поэтому не буду комментрировать.</p>

<p>Самое время привнести в наш проект немного магии, которое будет не мало. Первая магия &ndash; шаблоны на стороне клиента.</p>

<p>``` html</p>

<script type="text/template" id="book-template">
   <dl>
      <dt><a href="#" class="book-edit">Название:</a> <i class="icon-remove book-delete"></i></dt>
      <dd><input type="text" class="book-title"><span><%= title %></span></dd>

      <dt>Год издания: </dt>
      <dd><input type="text" class="book-year span3"><span><%= year %></span></dd>

      <dt>Автор: </dt>
      <dd><input type="text" class="book-author"><span><%= author %></span></dd>

      <dt>Жанр: </dt>
      <dd><input type="text" class="book-genre"><span><%= genre %></span></dd>

      <dt>ISBN: </dt>
      <dd><input type="text" class="book-isbn"><span><%= isbn %></span></dd>

      <dt>Статус: </dt>
      <dd>
         <select class="book-status">
            <option value="read">Прочитана</option>
            <option value="not-read">Не прочитана</option>
            <option value="want-read">Хочу прочитать</option>
         </select>
         <span><%= status %></span>
      </dd>
      <dt>Дата: </dt>
      <dd><input type="text" class="datepicker book-date"><span><%= date %></span></dd>

   </dl>
   <a class="btn btn-primary book-save">Сохранить</a>
</script>


<p>```</p>

<p>Казалось бы так похож на erb, но это просто совпадение, или разработчики данного шаблона рубисты. Вместо конструкций вида &lt;%= title %> в конечном html, появятся наши переменные, нам их нужно будет лишь заполнить. А верстка останется неизменной, что очень удобно.</p>

<p>Почти все, кроме одной строки, хотя эта одна строчка подключает сердце нашего приложения</p>

<p>``` html</p>

<script type="text/javascript" src="js/application.js"></script>


<p>```</p>

<p>Теперь самое время окунуться с головой в клиентское программирование (файл js/application.js).</p>

<p>Начнем, пожалуй, с модели.</p>

<p>``` javascript
var Book = Backbone.Model.extend({</p>

<pre><code>defaults: {
    title: "Book's title",
    year: 2009,
    author: "Murakami",
    genre: ["horror", "comedy"],
    isbn: "0128127622",
    status: "not read",
    image: "/images/placeholder.png",
    date: ''
},
</code></pre>

<p>});
```</p>

<p>Все модели нашего приложения должны расширять базовый класс Backbone.Model, свойство defaults, как понятно из названия отвечает за установку свойств модели по умолчанию. Я взял для примеры стандартные книжные свойства, большая часть из которых работает не до конца.</p>

<p>Теперь перейдем непосредственно к нашей библиотеке, расширив класс коллекции Backbone.Collection</p>

<p>``` javascript
var Library = Backbone.Collection.extend({</p>

<pre><code>//localStorage: new Store("BackboneCollection"),
url: '/books',
model: Book,
</code></pre>

<p>});
```</p>

<p>Закомментированная строка сохраняла бы всю нашу работу в local Storage браузера, мы же будем взаимодействовать с сервером, для этого нам понадобится адрес, по которому и будет производиться все общение (точнее будет основой для производных адресов). Последняя строка указывает коллекция каких объектов нами будет использоваться.</p>

<p>Если для модели нам не нужен объект, то для коллекции пригодится, поэтому создадим его.</p>

<p><code>javascript
var library = new Library();
</code></p>

<p>А сейчас начнется самое интересное &ndash; Представление. Будем разбирать его неспеша, чтобы ничего важного не упустить.</p>

<p>``` javascript
var BookView = Backbone.View.extend({</p>

<pre><code>    tagName: 'div',
    className: 'book',

    template: _.template($('#book-template').html()),

    events: {
        "click a.book-edit": "edit",
        "keypress input": "update",
        "click .book-delete": "clear",
        "click .book-save": "close",
    },
</code></pre>

<p>```</p>

<p>Сначала расширяем базовый класс Backbone.View, далее указываем элемент, с которым мы будем работать, в данном случае, это div с классом book. Следующая строка указывает какой шаблон мы будем рендерить и сохраняет его в переменной. В свойстве events мы перечисляем какие события мы будет &ldquo;прослушивать&rdquo;.
Каждая строка состоит из следующих моментов: сначала идет событие, которое мы будем обрабатывать, дальше &ndash; элемент, с которым это событие произойдет, после двоеточия &ndash; имя метода, который будет вызываться при наступлении прослушиваемого события.</p>

<p>Первая строка &ndash; нажимаем на ссылку &ndash; редактирование книги, вторая &ndash; нажимаем на кнопку (в указанном методе мы проверям Enter ли это) в текстовом поле &ndash; сохранить изменения. И последние две &ndash; это удаление и сохранение изменений.</p>

<p>Теперь опишим все методы нашего представления</p>

<p>``` javascript
initialize: function() {</p>

<pre><code>this.model.bind('change', this.render, this);
this.model.bind('destroy', this.remove, this);
</code></pre>

<p>},</p>

<p>update: function(e) {</p>

<pre><code>if (e.keyCode == 13) this.close();
</code></pre>

<p>},</p>

<p>close: function() {</p>

<pre><code>this.model.set(this._get());
this.model.save(this.model.toJSON());
    $(this.el).removeClass("editing");
</code></pre>

<p>},
```</p>

<p>Первым не важно для модели, коллекции или представления вызывается метод initialize, поэтому можно расценивать его как конструктор.</p>

<p>this.model будет во время работы приложения указывать на текущую модель, т.е. каждый кусок разметки будет связан с отдельной моделью, изменения в котором коснутся только одной модели, также как и наоборот. Первым делом мы связывем события модели с методами: первое это изменение модели, после которого должно произойти &ldquo;отрисовка&rdquo;, второе &ndash; удаление.</p>

<p>Метод <em>update</em> вызывается каждый раз, когда пользователь нажимает на клавиатуру, нам нужно отлавливать только нажатие Enter, чтобы сохранить изменения.</p>

<p>Метод <em>close</em> вызывается, когда пользователь нажал Enter или кликнул по кнопке &ldquo;Сохранить&rdquo;, посмотрите еще раз на последнюю строку из свойства events. В первой строке которого мы обновляем нашей модели свойств из текстовых полей. Дальше мы сохраняем модель и удаляем с себя класс редактирования (нужно будет для &ldquo;рюшечек&rdquo;).</p>

<p>Следующий метод, наверное, самый значимый, он отрисовывает все изменения модели на экране пользователя.</p>

<p>``` javascript
render: function() {</p>

<pre><code>$(this.el).html(this.template(this.model.toJSON()));
$(this.el).css({'background': ' no-repeat url(' + this.model.get('image') + ')'});
this.setText();
return this;
</code></pre>

<p>},
```</p>

<p><em>this.el</em> ни что иное, как tagName: &lsquo;div&rsquo; и className: &lsquo;book&rsquo;. Первая строка данного метода изменяет html элемента, учитывая новые свойства модели и учитывая разметку из шаблона. (Помните, мы писали недавно template: _.template($(&lsquo;#book-template&rsquo;).html())). Вторая строка данного метода заполняет фоновой картинкой наш кусок разметки.</p>

<p>&ldquo;Толстые&rdquo; методы для обновления свойств модели, исходя из значения текстовых полей или наоборот &ndash; текстоых полей, исходя их свойств модели.</p>

<p>``` javascript
setText: function() {</p>

<pre><code>var text = this.model.get('title');
this.$('.book span.book-title').text(text);
this.inputTitle = this.$('input.book-title');
this.inputYear = this.$('input.book-year');
this.inputAuthor = this.$('input.book-author');
this.inputGenre = this.$('input.book-genre');
this.inputIsbn = this.$('input.book-isbn');
this.inputStatus = this.$('select.book-status');
this.inputDate = this.$('input.book-date');
</code></pre>

<p>},
_fillForm: function() {</p>

<pre><code>var data = this.model.toJSON();
this.inputTitle.val(data.title);
this.inputYear.val(data.year);
this.inputAuthor.val(data.author);
this.inputGenre.val(data.genre);
this.inputIsbn.val(data.isbn);
this.inputStatus.val(data.status);
this.inputDate.val(data.date);
</code></pre>

<p>},</p>

<p>_get: function() {</p>

<pre><code>return {
    title: this.inputTitle.val(),
    year: this.inputYear.val(),
    author: this.inputAuthor.val(),
    genre: this.inputGenre.val(),
    isbn: this.inputIsbn.val(),
    status: this.inputStatus.val(),
    date: this.inputDate.val()
}
</code></pre>

<p>},
```</p>

<p>И последние 3 методя для данного представления:</p>

<p>``` javascript
edit: function() {</p>

<pre><code>$('div.book').removeClass('editing');
$(this.el).addClass('editing').find('input, select').fadeIn('slow');
this._fillForm();
this.inputTitle.focus();
return false;
</code></pre>

<p>},</p>

<p>clear: function() {</p>

<pre><code>if (confirm("Вы уверены?")) {
    this.model.destroy();
}
</code></pre>

<p>},</p>

<p>remove: function() {</p>

<pre><code>$(this.el).fadeOut('slow', function() {$(this).remove()});
</code></pre>

<p>}
```</p>

<p>Первый &ndash; уделяет класс редактирования со всех книг и устанавливает на активной и заполняет форму значениями модели (данный метод вызывается, когда пользователь нажмет на ссылку для редактирования).</p>

<p>Второй &ndash; задает пользователю вопрос, при утвердительном ответа на который удаляет данную модель.</p>

<p>Третий &ndash; вызывается автоматически и удаляет элемент со страницы, а вызывается он из-за того, что мы в конструкторе написали следующее:
<code>javascript
this.model.bind('destroy', this.remove, this);
</code></p>

<p>Осталось рассмотреть последнее представление и можно смело переходить к легкому backend'у.</p>

<p>``` javascript
var AppView = Backbone.View.extend({</p>

<pre><code>el: $('#books'),

events: {
    "click button": "create",
    "keypress #book-title": "createOnEnter"
},

initialize: function() {
    this.input = this.$('#book-title');
    library.bind('add', this.addOne, this);
    library.bind('reset', this.addAll, this);
    library.bind('all', this.render, this);
    library.fetch();
},

render: function() {
},
</code></pre>

<p>```</p>

<p>Данное представление отвечает за создание новых книг и загрузку книг с сервера. Книга создается заполнением только лишь названия, дальше ее можно отредактировать и сохранить. В конструкторе данного представления мы связываем необходимые события коллекции с методами, которые будет вызываться при наступлении событий. <strong>library.fetch();</strong> &ndash; запрашивает с сервера все книги, чтобы потом их отобразить.</p>

<p>Почему метод рендеринга пустой? Потому что он нам тут не нужен, все отрисовывается в методе добавления новой книги, с него и начнем продолжение рассказа.</p>

<p>``` javascript
addOne: function(book) {</p>

<pre><code>    var view = new BookView({model: book});
    var content = view.render().el;
    $(content).hide();
    $('#books').find('.book-container').prepend(content);
    $(content).show(1000);
},

addAll: function() {
    library.each(this.addOne);
},

createOnEnter: function(e) {
    if (e.keyCode == 13) {
        this.create();
    }
},

create: function(e) {
    var text = this.input.val();
    library.create({title: text});
    this.input.val('');
}
</code></pre>

<p>});</p>

<p>//$(&lsquo;.book-date&rsquo;).datepicker({});
var appView = new AppView();
```</p>

<p>Метод addOne добавляет в верстку одну книгу, создавая соответствующее представление. Метод addAll &ndash; пробегается по все коллекции книг и по одной с помощью метода addOne добавляет книги в верстку. Метод create создает для нас книгу с заголовком, который мы укажем в текстовом поле.</p>

<p>Осталось только создать нам представление приложения и наслаждаться результатом, хотя сначала нужно реализовать backend. Но он будет очень простым, поэтому быстрее перейдем к нему.</p>

<h3>Backend на Ruby</h3>

<p>Сначала общие моменты: подключение необходимых гемов, задание дефолтного подключения для DataMapper'а и описание класса Книга:</p>

<p>``` ruby</p>

<h1>coding: utf-8</h1>

<p>  require &lsquo;sinatra&rsquo;
  require &lsquo;data_mapper&rsquo;
  require &lsquo;json&rsquo;</p>

<p>  DataMapper.setup(:default, ENV[&lsquo;DATABASE_URL&rsquo;] || &lsquo;sqlite:./db/books.db&rsquo;)</p>

<p>  class Book</p>

<pre><code>include DataMapper::Resource

property :id,           Serial
property :title,        String
property :year,         Integer
property :date,         Date
property :image,        String
property :author,       String
property :genre,        String
property :isbn,         String
property :status,       String

#belongs_to :user
</code></pre>

<p>  end</p>

<p>  DataMapper.finalize</p>

<p>  get &lsquo;/&rsquo; do</p>

<pre><code>File.read('./public/index.html')
</code></pre>

<p>  end
```</p>

<p>Главной страницей у нас будет статичный файл .html
Теперь давайте сделаем небольшую паузу и поговорим о том, как взаимодействует Backbone.js с серверной частью. Если заглянуть в исходники, то там мы увидим следующее:</p>

<p>``` javascript
 var methodMap = {</p>

<pre><code>'create': 'POST',
'update': 'PUT',
'delete': 'DELETE',
'read':   'GET'
</code></pre>

<p>  };
```</p>

<p>Т.е. стандартный RESTfull запрос. Не будем оттягивать кота за яйца, закончим уже кодить над этим проектом, тем более, что Sinatra легко может обработать подобные запросы.</p>

<p>``` ruby
  get &lsquo;/books&rsquo; do</p>

<pre><code>content_type :json
Book.all(:order =&gt; :id).to_json
</code></pre>

<p>  end</p>

<p>  post &lsquo;/books&rsquo; do</p>

<pre><code>data = JSON.parse(request.body.gets)
Book.create(:title =&gt; data['title']);
</code></pre>

<p>  end</p>

<p>  put &lsquo;/books/:id&rsquo; do</p>

<pre><code>data = JSON.parse(request.body.gets)
book = Book.get(params[:id])
result = book.update(
  :title =&gt; data['title'],
  :year =&gt; data['year'],
  :author =&gt; data['author'],
  :genre =&gt; data['genre'],
  :isbn =&gt; data['isbn'],
  :status =&gt; data['status'],
  :image =&gt; '/images/placeholder.png', #data['image'],
  :date =&gt; Time.now
)
"false" unless result
</code></pre>

<p>  end</p>

<p>  delete &lsquo;/books/:id&rsquo; do</p>

<pre><code>Book.get(params[:id]).destroy
</code></pre>

<p>  end
```</p>

<p>Здесь нет ничего сложного, если есть какие-то сложности, посмотрите мои предыдущие заметки о Ruby и о Sinatra.</p>

<h3>Заключение</h3>

<p>Еще одно приложение мы разработали с вами на ruby, сегодня не обошлось без так важного на сегодняший день клиентсткого программирования. Ссылка на <a href="http://vredniy-library.heroku.com/">пример</a> (редактирование и создание не сохраняются в базе)  и ссылка на <a href="https://github.com/vredniy/Backbone-sinatra">исходник</a>.
<img class="image" src="/images/posts/2012-02-backbone-js-sinatra-ruby/placeholder.png">
Всем спасибо за внимание и до новых встреч :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sinatra и Whois gem: маленькое приложение]]></title>
    <link href="http://zudochkin.ru/2011/11/ruby-sinatra-whois"/>
    <updated>2011-11-18T02:26:34+04:00</updated>
    <id>http://zudochkin.ru/2011/11/ruby-sinatra-whois</id>
    <content type="html"><![CDATA[<p>Здравствуйте, уважаемые коллеги и те, кто может случайно забрел на мой блог. Сегодня речь пойдет о Ruby, но я не буду вдаваться в подробное описание языка, поэтому ограничимся базовой функциональностью замечательного фреймворка Sinatra.</p>

<!-- more -->


<h3>Вступление</h3>

<p>Мой отпуск подходит плавно к концу, но чтобы не зря тратить время решил я посвятить его изучению нового для меня языка программирования. Почему Ruby, возможно назреет у вас вопрос. Отвечу так: я долго шел к смене языка программировани, нет, это не из-за того, что мне не нравится PHP, отнюдь, но захотелось чего-то другого во время отпуска, тем более, что время позволяет. Прежде чем остановиться на Ruby, мною было прочитано много килобайт материала, просмотрено много мегабайт видео презентаций и скринкастов, и я решил более не задаваться глупыми вопросами, а может Python, может еще что-нибудь, решил просто попробовать.</p>

<p><img class="image" src="/images/posts/2011-11-ruby-sinatra-whois/ruby-sinatra-300x197.png">Почему Sinatra, а не Rails? Все просто: чтобы понять как работает такой большой веб-фреймворк, как Rails, понадобится намного больше времени, да и понять его без хорошего знания Ruby, я не рискну, а Sinatra в этом отношении в разы полегче, можно сказать, что это чистый Ruby.</p>

<h3>Постановка задачи</h3>

<p>Задача будет проста до безумия: у нас будет иметься одна страница с одним текстовым полем. Если мы введем туда корректное имя домена, приложение ответит нам доступен ли домен для регистрации и срок истечения, если домен зарегистрирован.</p>

<h3>Используемый инструментарий</h3>

<p>В первую очередь нам, конечно же, понадобится сервер с установленным на нем Ruby, локальный вполне подойдет. В этой короткой заметке я не буду рассказывать как его [сервер] установить, в интернете полным-полно подобных мануалов и раскрывают они тему исчерпывающе. В дополнение к гему sinatra, нам также понадобятся: whois (http://goo.gl/0jEJA) и гем json (им мы будем отдавать ответ).</p>

<h3>Реализация</h3>

<p>Приложение у нас будет состоять из двух экшнов: первый это главная страница, на которой и будет отображаться текстовый элемент и экшн, который будет отвечать за прием данных по средством AJAX, отправку запроса серверу whois и возвращению ответ в формате JSON.
Шаблонизатором у нас будет выступать HAML, очень удобная и простая штука, так что приведу код шаблона главной страницы в формате haml.</p>

<p>``` ruby
!!!
%html
  %head</p>

<pre><code>%meta{:content =&gt; "text/html; charset=UTF-8", "http-equiv" =&gt; "content-type"}/
%script{:type =&gt; 'text/javascript', :src =&gt; 'http://yandex.st/jquery/1.7.0/jquery.min.js'}
%script{:type =&gt; 'text/javascript', :src =&gt; '/javascripts/default.js'}
%title Маленькое приложение на Руби (Sinatra, Whois, Json)
</code></pre>

<p>  %body</p>

<pre><code>%div
  %p Впишите какой-нибудь, желательно, корректный домен и нажмите Enter
  %form{:method =&gt; 'post', :action =&gt; '/ajax.json'}
    %input{:type =&gt; "text", :name =&gt; "domain"}
  %ul{:id =&gt; 'info'}
</code></pre>

<p>```</p>

<p>Также приведу исходных код экшна главной страницы, который занимает всего 1 строчку. Его задача только отобразить шаблон.</p>

<p><code>ruby
get '/' do
   haml :index
end
</code></p>

<p>Наш AJAX экшн будет срабатывать по POST запросу при отсылке данных по адресу /ajax.json</p>

<p>``` ruby
  post &lsquo;/ajax.json&rsquo; do</p>

<pre><code>domain = params[:domain]

begin
  info = Whois.query(domain)
rescue Whois::ServerNotFound
end
content_type :json

{ :domain =&gt; domain, :info =&gt; {:available =&gt; info.available?, :registered =&gt; info.registered?, :expires =&gt; info.expires_on} }.to_json unless info.nil?
</code></pre>

<p>  end
```</p>

<p>В первой строке которого мы получаем имя домена через форму. Далее получаем необходимую информацию о домене, для того чтобы не сыпались в приложении исключения я оборачиваю вызов кода, который легко может выбросить исключения в обертку аля PHP try-catch. <strong>content_type json</strong>, как вы догадались, устанавливает формат ответа. В последней строке мы формируем JSON. Что удобно в Ruby, так это то, что не нужно возвращать значения, данный язык делает это сам, т.е. последняя строка в методе возвращает значение.</p>

<p>Осталось только связать нашу форму на главной странице и AJAX экшн. Для этих целей очень хорошо подойдет несколько строк на замечательном JavaScript-фреймворке jQuery. Задача &ndash; отправить AJAX запрос методом POST, дождаться ответа от сервера и заполнить список полями из полученного JSON.</p>

<p>``` javascript
$(function() {
  $(&lsquo;form&rsquo;).submit(function() {</p>

<pre><code>$.post('/ajax.json', $(this).serialize(), function(data) {
  if (!data) {
    alert('Что-то пошло не так (');
    return;
  }
  $('ul#info &gt; *').remove();
  $.each(data.info, function(field, value) {
    $('ul#info').append('
</code></pre>

<ul>
<li><strong>&lsquo; + field + &rsquo;</strong> &lsquo; + value + &rsquo;
&lsquo;)
    });
    console.log(data);
  }, 'json&rsquo;);
  return false;
});
});
```</li>
</ul>


<h3>Исходный код</h3>

<p>Исходный код вы можете посмотреть на гитхабе, <a href="https://github.com/vredniy/sinatra-whois">здесь</a>.</p>

<h3>Заключение</h3>

<p>Это была моя первая заметка на тему Ruby, надеюсь, мой блог и дальше будет пополняться подобными постами, потому что язык мне очень нравится, нравится своей гибкостью и необычностью (как программист на PHP говорю). Спасибо зв внимание и до новых встреч.</p>
]]></content>
  </entry>
  
</feed>
