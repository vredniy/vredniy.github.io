---
author: admin
comments: true
date: 2011-06-07 07:43:34+00:00
layout: post
slug: jquery-for-beginners-confusing-part1

permalink: /2011/06/jquery-for-beginners-confusing-part1

title: Общие заблуждения о jQuery (часть 1) parent, parents, closest
wordpress_id: 716
categories:
- javascript
- jQuery
tags:
- jQuery
---

Быстрый рост JavaScript библиотек и разнообразных фреймворков, таких как jQuery, для программирования на стороне клиента, предоставил всю мощь языка JavaScript для широкой аудитории. jQuery предоставляет свой собственный API, методы и синтаксические особенности. Порой которые похожи друг на друга, но отличающиеся в чем-то. Это заметка должна избавить вас от путаницы
<!-- more -->


###  .parent(), .parents() .closest()


Все три эти метода предоставляют доступ вверх над элементами по дереву DOM, но они тем временем все-таки отличаются



#### parent(selector)


Попросту находит одного непосредственного родителя для элемента или элементов. Он также может принимать селектор в виде параметра, который будет полезен для нахождения родителя в определенном контексте.

[cc lang="javascript"]
	$('span.my').parent().css('border', '1px solid red');
	$('p').parent('div.sidebar').css('border', '1px solid red');
[/cc]

В первой строке мы получаем родителя с классом my. Во второй же получает родителей для всех элементов <p>, при условии, что родитель его <div> с классом .sidebar.

Возможность ограничить выборку метода как во второй строке в примере выше - стандартная "плюшка" jQuery. Большинство методов для DOM-манипуляций позволяют указать селектор.




####  parents(selector)


Работает по тому же принципу, что и .parent() за исключением того, что данный метод не ограничен одним уровнем и может возвращать несколько предков. К примеру:

[cc lang="html"]
	$('li.naivgation').parents('li');
[/cc]

Для каждого элемента <li> который содержит в себе класс **navigation**, возвращает всех родителей и предков, который в свою очередь тоже элементы списка <li>. Данный метод может быть полезен с многоуровнемым меню.

[cc lang="html"]
	


		
  * Catalog
			
				
    * Electronics

				
    * Animals

				
    * Birds

			
		

		
  * About...
			
				
    * me

				
    * company

			
		

	
[/cc]

Допустим нам нужно поменять цвет фона только для третьего уровня вложенности:

[cc lang="javascript"]
	$('.navigation li').each(function() {
		if (2 == $(this).parents('.navigation li').length)
			$(this).css('background-color', 'cyan');
	});
[/cc]

Для каждого элемента <li>, найденного в классе **navigation** находим количество <li>-предков. Если это два, значит раскрашиваем его.



#### closest(selector)


Это больше магия, но очень полезная. Данный метод работает также как и .parents(), исключая то, что возвращает только одного родителя или предка. Бывают ситуации, когда вам не нужны все родители, возвращаемые методом .parents(), тогда в дело вступает метод .closest(). Допустим, нам нужно узнать явлвется ли один элемент непосредственным наследником другого:

[cc lang="javascript"]
	if (1 == $('.elem1').closest('.elem2').length)
		console.log('Непосредственный предок');
	else
		console.log('Дальний родственник :)');
[/cc]



Метод .closest() легко сэмулировать методом .parents(), ограничив количество возвращаемых элементов:


[cc lang="javascript"]
	$($('.elem1').parents('.elem2').get(0)).css('border', '1px solid red');
[/cc]

И еще метод .closest() начинает обход, начиная с элемента, удовлетворяющему селектору, а не с его родителя. 
