<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jQuery | Записки Вредного программиста]]></title>
  <link href="http://zudochkin.ru/blog/categories/jquery/atom.xml" rel="self"/>
  <link href="http://zudochkin.ru/"/>
  <updated>2014-02-02T23:53:57+04:00</updated>
  <id>http://zudochkin.ru/</id>
  <author>
    <name><![CDATA[Зудочкин Дима]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Полиморфная связь и TokenInput jQuery]]></title>
    <link href="http://zudochkin.ru/2012/04/polymorphic-relations-and-token-input-jquery"/>
    <updated>2012-04-18T23:26:02+04:00</updated>
    <id>http://zudochkin.ru/2012/04/polymorphic-relations-and-token-input-jquery</id>
    <content type="html"><![CDATA[<p>Представьте ситуацию, что у вас имеется некая модель, к которой вы хотите добавлять по средствам связей другие модели. Хорошо, когда данную связь можно описать обычным <strong>has_many</strong>, другое дело, когда нужно привязать разнородные модели, к примеру, у вас имеется модель вопросов, к которой нужно привязать город или страну <!-- more -->(не очень наглядный пример, вряд ли он вам в жизни встретится, но я поделюсь своим опытом).</p>

<p>Как вы, наверное, догадались, основным инструментом будет выступать ruby an rails. Из гемов будем использовать <strong>simple_form</strong> для удобного создания форм, <strong>inherited_resources</strong>, чтобы писать намного меньше кода в контроллерах (сейчас не представляю без этого гема жизни).</p>

<p>Также нам понадобится плагин для jQuery <a href="http://loopj.com/jquery-tokeninput/">tokenInput</a>, который будет отображать выпадающий список с autoComplete'ом, из которого мы сможем выбрать одно значение из стран или городов (список будет один).</p>

<h3>Реализация</h3>

<p>Начнем с контроллера <strong>QuestionableController</strong> (не очень, конечно, удачное название), который будет отдавать солянку из городов и стран с возможностю поиска.
``` ruby
class QuestionableController &lt; ApplicationController
  def index</p>

<pre><code>countries = Country.find(:all, conditions: ['name LIKE(?)', "%#{ params[:q]
cities = City.find(:all, conditions: ['name LIKE(?)', "%#{ params[:q] }%"])

@questionable = countries + cities

respond_to do |format|
  format.json { render }
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Лучше вынести всю логику в модель, но данный пример создан исключительно для демонстрации. Что мы делаем в этом контроллере? Ищем страны и города, удовлетворяющих параметру <strong>q</strong> и заполняем инстанс переменную <strong>@questionable</strong></p>

<p>Также давайте заполним нашу вьюшку <em>index.json.erb</em></p>

<p>``` ruby
&lt;%= sanitize @questionable.to_json(methods: [:id_with_class_name], only: [:id, :name]) %></p>

<p>```</p>

<p>в которой мы рендерим наш json, т.к. нам не нужны все поля модели мы используем только необходимые <code>(only: [:id, :name])</code>, ключ methods: указывает на то, что мы помимо физических свойст, будем использовать метод модели <em>id_with_class_name</em>.</p>

<p>Пока не забыл, давайте пропишем пару строк в наш <em>config/routes.rb</em></p>

<p><code>ruby
resources :questions # для того, чтобы создавать/показывать/удалять вопросы
resources :questionable, only: :index # для того, чтобы отображать json
</code></p>

<p>Перейдем к моделям:</p>

<p><em>models/question.rb</em>
``` ruby
class Question &lt; ActiveRecord::Base
  attr_accessor :location</p>

<p>  belongs_to :questionable, polymorphic: true
  attr_accessible :name, :questionable_id, :questionable_type</p>

<p>  before_save do</p>

<pre><code>return unless self.location =~ /_/
location_id, location_type = self.location.split('_')
self.questionable_id   = location_id   unless location_id.nil?
self.questionable_type = location_type unless location_type.nil?
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Самая интересная строчка &ndash; это та, которая начинается с <code>belongs_to</code>, в ней мы объявляем полиморфную связь questionable. Дальше идет метод, который мы вызываем каждый раз перед сохранением в базу данных. В нем мы парсим строку из autoComplete'а, которая будет иметь вид id_ModelName и сохраняем отдельно id и ModelName.</p>

<p>Модель <em>city.rb</em>
``` ruby
class City &lt; ActiveRecord::Base
  has_many :questions, as: :questionable
  attr_accessible :name</p>

<p>  def id_with_class_name</p>

<pre><code>"#{ id }_#{ self.class.name }"
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>В ней объявляется связь <code>has_many</code> через questionable, который мы обявили в модели question полиморфной. Далее идем метод, который возвращает id записи и название класса модели (чтобы можно было отделить зерно от плевел).</p>

<p>Модель <em>country.rb</em> почти такая же
``` ruby
class Country &lt; ActiveRecord::Base
  has_many :questions, as: :questionable
  attr_accessible :name</p>

<p>  def id_with_class_name</p>

<pre><code>"#{ id }_#{ self.class.name }"
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Связь обявлена также как и в предыдущей модели.</p>

<p>Наш маленький контроллер <em>QuestionController</em>
<code>ruby
class QuestionsController &lt; InheritedResources::Base
end
</code>
где остальное спросите вы. Это все. Это все, что нам нужно для того, чтобы создавать, удалять, редактировать вопросы. Как вы, наверное, заметили наш контроллер наследуется не от ApplicationController'а, а от inherited_resources. Что это значит? А это значит, если абстрагироваться от 80% возможностей этого гема, то, что гем берет всю &ldquo;грязную&rdquo; работу на себя, предоставляя нам в пользование переменные resource и collection, хранятся в которых ссылка на текущую запись (resource) и список всех записей (collection) соответственно. Для того, чтобы мы смогли создать свой первый вопрос нам необходимы лишь вьюшки. Начнем с _form.html.erb, которую мы будем подключать и в создании вопроса, и в редактировании.</p>

<p><em>app/views/questions/</em>form.html.erb_</p>

<p>``` ruby
&lt;%= simple_form_for resource do |f| %>
  &lt;% pre = if resource.questionable %></p>

<pre><code>&lt;% [resource.questionable].to_json(only: [:id, :name]) %&gt;
</code></pre>

<p>  &lt;% end %>
  &lt;%= f.input :name %>
  &lt;%= f.input :location, input_html: { &lsquo;data-pre&rsquo; => pre, class: &lsquo;token-input-questionable&rsquo; } %>
  &lt;%= f.submit nil %>
&lt;% end %></p>

<p>```</p>

<p>Как видите, почти никаких различий с нативным form_for нет. Во второй строке мы заполняем переменную pre json'ом выбранного города или страны, в предпоследней создаем инпут с атрибутом data-pre, равным json'у и классом, чтобы мы могли найти этот элемент без проблем.</p>

<p><em>new.html.erb</em> и <em>edit.html.erb</em> абсолютно одинаковы и представляют собой следующее:</p>

<p><code>ruby
&lt;%= render 'form' %&gt;
</code></p>

<p>в них мы отрисовываем только форму.</p>

<p>Далее кинем наш скачанный jquery.tokeninput.js в папку <em>app/assets/javascripts</em> и допишем в <em>application.js</em> следующее:</p>

<p>``` javascript
$(function() {
  var $input = $(&lsquo;.token-input-questionable&rsquo;);
   $input.tokenInput(&lsquo;/questionable.json&rsquo;, {</p>

<pre><code>  tokenLimit: 1,
  tokenValue: 'id_with_class_name',
  prePopulate: $input.data('pre')
});
</code></pre>

<p>});</p>

<p>```</p>

<p>Первым параметром к tokenInput мы указываем откуда брать данные, tokenLimit:1 указывает на то, что одной записи нам будет достаточно (одного элемента из выпадающего списка), tokenValue &ndash; откуда мы будем брать имя, которое будем отображать из json'а, prePopulate используем для того, чтобы заполнить элемент, если мы его уже выбрали (редактирование).</p>

<p><img class="image" src="/images/posts/2012-04-polymorphic-relations-and-token-input-jquery/rsz_1screenshot_from_2012-04-18_230555-300x209.png"></p>

<p>Сумбурным получилось изложения материала, потому что для меня это в новинку и писалось это для того, чтобы не забыть полезную &ldquo;плюшку&rdquo; в дальнейшем. Если заметка кому-нибудь еще пригодится, я буду очень рад :)</p>

<p>P.S.: Если данную заметку читает Александр, мало ли, то, надеюсь, он будет не против, что я позаимствовал его идею :)</p>

<p>Демо проект &ldquo;лежит&rdquo; на <a href="http://vredniy-polymorphic.heroku.com/questions/">heroku</a>, репозиторий, как всегда на <a href="https://github.com/vredniy/rails-token-input">github</a> (там же лежат и миграции, нужные для запуска проекта).</p>

<p>Удачи вам в любых начинаниях и до новых встреч :)</p>
]]></content>
  </entry>
  
</feed>
